<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/dat.gui.min.js"></script>
<script src="js/TrackballControls.js"></script>

<script>
    var scene, camera, light, backgroundLight, renderer;
    var geom;
    var raycaster, mouseVector,INTERSECTED, SELECTED;
    var range = 80;
    var plane = new THREE.Plane();
    var offset = new THREE.Vector3();
    var intersection = new THREE.Vector3();

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setClearColor(0xdddddd);
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,1000);
    camera.position.set(0,0,range * 2);
    camera.lookAt(new THREE.Vector3(0,0,0));

    controls = new THREE.TrackballControls( camera );
    controls.zoomSpeed = 0.1;

//    var clock = new THREE.Clock();


    light = new THREE.PointLight(0xffffcc, 1);
    light.position.set(10,70,100);
    scene.add(light);

    backgroundLight = new THREE.PointLight(0xffffcc, 0.5);
    backgroundLight.position.set(-10,-30,-50);
    scene.add(backgroundLight);

    geom = new THREE.SphereBufferGeometry(5,16,16);


    for (var i=0;i<100;i++) {
        var grayness = Math.random() * 0.5 +0.25,
                mat = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ),
                ball = new THREE.Mesh (geom,mat);
        ball.position.set(range *(0.5 - Math.random()), range *(0.5 - Math.random()),range *(0.5 - Math.random()));
        ball.grayness = grayness;
        scene.add(ball);
    }

    raycaster = new THREE.Raycaster();
    mouseVector = new THREE.Vector2();


    document.addEventListener('mousemove', onMouseMove, false);
    document.addEventListener('mousedown', onMouseDown, false);
    document.addEventListener('mouseup', onMouseUp, false);

    function onMouseMove(e) {
        mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
        mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );

        raycaster.setFromCamera(mouseVector.clone(), camera);
        var intersects = raycaster.intersectObjects( scene.children );

        if ( intersects.length > 0 ) {

            if ( INTERSECTED != intersects[ 0 ].object ) {

                if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
                INTERSECTED = intersects[ 0 ].object;
                INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                INTERSECTED.material.emissive.setHex( 0xFFFF99 );

                plane.setFromNormalAndCoplanarPoint(
                        camera.getWorldDirection( plane.normal ),
                        INTERSECTED.position );
            }
        } else {
            if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
            INTERSECTED = null;
        }

        if (SELECTED) {
            if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

                SELECTED.position.copy( intersection.sub( offset ) );

            }

        }

    }

    function onMouseDown(e) {
        mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
        mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );

        raycaster.setFromCamera(mouseVector.clone(), camera);
        var intersects = raycaster.intersectObjects( scene.children );


        if ( intersects.length > 0 ) {
            controls.enabled = false;

            if ( SELECTED != intersects[ 0 ].object ) {
                SELECTED = intersects[ 0 ].object;
            }
        }

    }

    function onMouseUp() {
        controls.enabled = true;
        SELECTED = null;
    }

    function transVector () {
        var vector = new THREE.Vector3();

        vector.set(
                ( event.clientX / window.innerWidth ) * 2 - 1,
                - ( event.clientY / window.innerHeight ) * 2 + 1,
                -1);

        vector.unproject( camera );

        var dir = vector.sub( camera.position ).normalize();

        var distance = - camera.position.z / dir.z;

        var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        return pos;
    }


    function animate() {
        requestAnimationFrame( animate );
        controls.update();
        render();
//        update()
    }

//    function update() {
//        var delta = clock.getDelta();
//        controls.update(delta);
//    }



    function render() {

        renderer.render( scene, camera );
    }

    animate();

    window.addEventListener( 'resize', function () {

        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }, false );


</script>
</body>
</html>